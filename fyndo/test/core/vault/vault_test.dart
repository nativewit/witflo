// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FYNDO - Zero-Trust Notes OS
// Vault Tests - Vault Creation, Unlock, and Management Tests (v2 API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// UPDATED FOR SPEC-002: Workspace Master Password Architecture
//
// These tests use the new vault API where:
// - Vaults no longer have individual passwords
// - Vault keys are random (generated by workspace)
// - Password change is workspace-level (not tested here)
//
// See: docs/specs/spec-002-workspace-master-password.md
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import 'dart:io';
import 'dart:typed_data';

import 'package:flutter_test/flutter_test.dart';
import 'package:fyndo_app/core/crypto/crypto.dart';
import 'package:fyndo_app/core/vault/vault.dart';
import 'package:uuid/uuid.dart';

void main() {
  late CryptoService crypto;
  late VaultService vaultService;
  late Directory tempDir;

  setUpAll(() async {
    crypto = await CryptoService.initialize();
    vaultService = VaultService(crypto);
  });

  setUp(() async {
    // Create a fresh temp directory for each test
    tempDir = await Directory.systemTemp.createTemp('fyndo_test_');
  });

  tearDown(() async {
    // Clean up temp directory
    if (await tempDir.exists()) {
      await tempDir.delete(recursive: true);
    }
  });

  group('VaultHeader v2', () {
    test('should create header with correct fields (no salt/kdfParams)', () {
      final vaultId = const Uuid().v4();

      final header = VaultHeader.create(vaultId: vaultId);

      expect(header.version, equals(currentVaultVersion));
      expect(header.vaultId, equals(vaultId));
      expect(header.createdAt, isNotNull);
      expect(header.modifiedAt, isNull);
    });

    test('should serialize and deserialize', () {
      final vaultId = const Uuid().v4();
      final header = VaultHeader.create(vaultId: vaultId);

      final bytes = header.toBytes();
      final restored = VaultHeader.fromBytes(bytes);

      expect(restored.version, equals(header.version));
      expect(restored.vaultId, equals(header.vaultId));
      expect(restored.createdAt, equals(header.createdAt));
    });

    test('should update modification time on touch', () {
      final vaultId = const Uuid().v4();
      final header = VaultHeader.create(vaultId: vaultId);

      final originalCreated = header.createdAt;
      expect(header.modifiedAt, isNull);

      final touched = header.touch();

      expect(touched.createdAt, equals(originalCreated));
      expect(touched.modifiedAt, isNotNull);
    });
  });

  group('VaultFilesystem', () {
    test('should initialize directory structure', () async {
      final vaultPath = '${tempDir.path}/vault';
      final filesystem = VaultFilesystem(vaultPath);

      await filesystem.initialize();

      expect(await Directory(filesystem.paths.rootPath).exists(), isTrue);
      expect(await Directory(filesystem.paths.objectsDir).exists(), isTrue);
      expect(await Directory(filesystem.paths.refsDir).exists(), isTrue);
      expect(await Directory(filesystem.paths.syncDir).exists(), isTrue);

      // Check hash prefix directories
      expect(
        await Directory('${filesystem.paths.objectsDir}/00').exists(),
        isTrue,
      );
      expect(
        await Directory('${filesystem.paths.objectsDir}/ff').exists(),
        isTrue,
      );
    });

    test('should report vault existence correctly', () async {
      final vaultPath = '${tempDir.path}/vault';
      final filesystem = VaultFilesystem(vaultPath);

      expect(await filesystem.exists(), isFalse);

      // Create minimal vault files
      await filesystem.initialize();
      await File(filesystem.paths.header).writeAsString('{}');

      expect(await filesystem.exists(), isTrue);
    });

    test('should write and read objects', () async {
      final vaultPath = '${tempDir.path}/vault';
      final filesystem = VaultFilesystem(vaultPath);
      await filesystem.initialize();

      final data = Uint8List.fromList([1, 2, 3, 4, 5]);
      final hash = 'abcdef1234567890abcdef1234567890';

      await filesystem.writeObject(hash, data);

      final read = await filesystem.readObject(hash);

      expect(read, equals(data));
    });

    test('should generate correct object path', () {
      final filesystem = VaultFilesystem('/vault');
      final hash = 'abcdef1234567890';

      final path = filesystem.paths.objectPath(hash);

      expect(path, equals('/vault/objects/ab/cdef1234567890'));
    });

    test('should write atomically', () async {
      final vaultPath = '${tempDir.path}/vault';
      final filesystem = VaultFilesystem(vaultPath);
      await filesystem.initialize();

      final filePath = '$vaultPath/test.txt';
      final data = [1, 2, 3, 4, 5];

      await filesystem.writeAtomic(filePath, data);

      expect(await File(filePath).exists(), isTrue);
      expect(await File('$filePath.tmp').exists(), isFalse);
      expect(await File(filePath).readAsBytes(), equals(data));
    });
  });

  group('VaultService - Creation (v2 API)', () {
    test('should create new vault with random vault key', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      final result = await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'Test Vault',
        description: 'A test vault',
        icon: 'ðŸ“',
        color: '#FF5733',
      );

      expect(result.vaultPath, equals(vaultPath));
      expect(result.header.version, equals(currentVaultVersion));
      expect(result.header.vaultId, equals(vaultId));
      expect(await File('$vaultPath/vault.header').exists(), isTrue);
      expect(await File('$vaultPath/vault.metadata.json').exists(), isTrue);

      // Clean up
      vaultKey.dispose();
    });

    test('should fail if vault already exists', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId1 = const Uuid().v4();
      final vaultId2 = const Uuid().v4();
      final vaultKey1 = VaultKey(crypto.random.symmetricKey());
      final vaultKey2 = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey1,
        vaultId: vaultId1,
        name: 'Vault 1',
      );

      expect(
        () => vaultService.createVault(
          vaultPath: vaultPath,
          vaultKey: vaultKey2,
          vaultId: vaultId2,
          name: 'Vault 2',
        ),
        throwsA(isA<VaultException>()),
      );

      // Clean up
      vaultKey1.dispose();
      vaultKey2.dispose();
    });
  });

  group('VaultService - Unlock (v2 API)', () {
    test('should unlock vault with correct vault key', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'Test Vault',
      );

      final vault = await vaultService.unlockVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
      );

      expect(vault.vaultKey, isNotNull);
      expect(vault.vaultKey.isDisposed, isFalse);
      expect(vault.header.vaultId, equals(vaultId));

      vault.dispose();
      vaultKey.dispose();
    });

    test('should fail unlock if vault not found', () async {
      final vaultPath = '${tempDir.path}/nonexistent';
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      expect(
        () =>
            vaultService.unlockVault(vaultPath: vaultPath, vaultKey: vaultKey),
        throwsA(
          isA<VaultException>().having(
            (e) => e.error,
            'error',
            VaultError.vaultNotFound,
          ),
        ),
      );

      vaultKey.dispose();
    });

    test('should unlock vault multiple times with same key', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'Test Vault',
      );

      // Unlock first time
      final vault1 = await vaultService.unlockVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
      );
      expect(vault1.vaultKey, isNotNull);
      vault1.dispose();

      // Unlock second time (same key)
      final vault2 = await vaultService.unlockVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
      );
      expect(vault2.vaultKey, isNotNull);
      vault2.dispose();

      vaultKey.dispose();
    });
  });

  group('VaultService - Key Derivation', () {
    test('should derive content keys from unlocked vault', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'Test Vault',
      );

      final vault = await vaultService.unlockVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
      );

      final ck1 = vault.deriveContentKey('note-1');
      final ck2 = vault.deriveContentKey('note-2');
      final ck1Again = vault.deriveContentKey('note-1');

      // Same note ID should return cached key
      expect(ck1.material.bytes, equals(ck1Again.material.bytes));
      // Different note IDs should have different keys
      expect(ck1.material.bytes, isNot(equals(ck2.material.bytes)));

      vault.dispose();
      vaultKey.dispose();
    });

    test('should derive notebook keys', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'Test Vault',
      );

      final vault = await vaultService.unlockVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
      );

      final nk = vault.deriveNotebookKey('notebook-123');

      expect(nk.notebookId, equals('notebook-123'));
      expect(nk.material.length, equals(32));

      vault.dispose();
      vaultKey.dispose();
    });

    test('should derive search index key', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'Test Vault',
      );

      final vault = await vaultService.unlockVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
      );

      final searchKey1 = vault.deriveSearchIndexKey();
      final searchKey2 = vault.deriveSearchIndexKey();

      // Should return cached key
      expect(searchKey1.material.bytes, equals(searchKey2.material.bytes));

      vault.dispose();
      vaultKey.dispose();
    });
  });

  group('Unlocked Vault Lifecycle', () {
    test('should dispose all keys on vault dispose', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'Test Vault',
      );

      final vault = await vaultService.unlockVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
      );

      // Derive some keys
      vault.deriveContentKey('note-1');
      vault.deriveNotebookKey('notebook-1');
      vault.deriveSearchIndexKey();

      // Dispose vault
      vault.dispose();

      // Vault key should be disposed
      expect(vault.vaultKey.isDisposed, isTrue);

      vaultKey.dispose();
    });

    test('should handle multiple vaults independently', () async {
      final vault1Path = '${tempDir.path}/vault1';
      final vault2Path = '${tempDir.path}/vault2';
      final vaultId1 = const Uuid().v4();
      final vaultId2 = const Uuid().v4();
      final vaultKey1 = VaultKey(crypto.random.symmetricKey());
      final vaultKey2 = VaultKey(crypto.random.symmetricKey());

      // Create two vaults
      await vaultService.createVault(
        vaultPath: vault1Path,
        vaultKey: vaultKey1,
        vaultId: vaultId1,
        name: 'Vault 1',
      );
      await vaultService.createVault(
        vaultPath: vault2Path,
        vaultKey: vaultKey2,
        vaultId: vaultId2,
        name: 'Vault 2',
      );

      // Unlock both
      final unlockedVault1 = await vaultService.unlockVault(
        vaultPath: vault1Path,
        vaultKey: vaultKey1,
      );
      final unlockedVault2 = await vaultService.unlockVault(
        vaultPath: vault2Path,
        vaultKey: vaultKey2,
      );

      // Derive keys from each
      final ck1 = unlockedVault1.deriveContentKey('note-1');
      final ck2 = unlockedVault2.deriveContentKey('note-1');

      // Keys should be different (different vault keys)
      expect(ck1.material.bytes, isNot(equals(ck2.material.bytes)));

      // Dispose both
      unlockedVault1.dispose();
      unlockedVault2.dispose();
      vaultKey1.dispose();
      vaultKey2.dispose();
    });
  });

  group('VaultMetadata', () {
    test('should save and load vault metadata', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'My Vault',
        description: 'Test description',
        icon: 'ðŸ”',
        color: '#FF5733',
      );

      final metadata = await vaultService.loadVaultMetadata(vaultPath);

      expect(metadata, isNotNull);
      expect(metadata!.vaultId, equals(vaultId));
      expect(metadata.name, equals('My Vault'));
      expect(metadata.description, equals('Test description'));
      expect(metadata.icon, equals('ðŸ”'));
      expect(metadata.color, equals('#FF5733'));

      vaultKey.dispose();
    });

    test('should update vault metadata', () async {
      final vaultPath = '${tempDir.path}/vault';
      final vaultId = const Uuid().v4();
      final vaultKey = VaultKey(crypto.random.symmetricKey());

      await vaultService.createVault(
        vaultPath: vaultPath,
        vaultKey: vaultKey,
        vaultId: vaultId,
        name: 'Original Name',
      );

      final original = await vaultService.loadVaultMetadata(vaultPath);
      expect(original!.name, equals('Original Name'));

      final updated = original.rebuild(
        (b) => b
          ..name = 'Updated Name'
          ..description = 'New description',
      );

      await vaultService.saveVaultMetadata(vaultPath, updated);

      final loaded = await vaultService.loadVaultMetadata(vaultPath);
      expect(loaded!.name, equals('Updated Name'));
      expect(loaded.description, equals('New description'));

      vaultKey.dispose();
    });
  });
}
